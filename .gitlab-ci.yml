stages:
  - validate
  - build
  - test
  - deploy-prod

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  REGISTRY_IMAGE: $CI_REGISTRY_IMAGE
  BACKEND_IMAGE: $CI_REGISTRY_IMAGE/backend
  FRONTEND_IMAGE: $CI_REGISTRY_IMAGE/frontend

# Cache Docker layers
.docker_cache: &docker_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .docker-cache/

# Validate stage - Check code quality and configuration
validate:yaml:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache yamllint
  script:
    - yamllint docker-compose.yml docker-compose.dev.yml .gitlab-ci.yml || true
    - echo "YAML validation completed"
  only:
    - merge_requests
    - main
    - develop

validate:dockerfiles:
  stage: validate
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker info
  script:
    - |
      echo "Validating Dockerfiles..."
      docker build --target builder -f backend/Dockerfile.prod -t test-backend:latest ./backend || true
      docker build --target builder -f frontend/Dockerfile.prod -t test-frontend:latest ./frontend || true
      echo "Dockerfile validation completed"
  only:
    - merge_requests
    - main
    - develop

# Build stage - Build Docker images
build:backend:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  <<: *docker_cache
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      echo "Building backend Docker image..."
      docker build -f backend/Dockerfile.prod -t $BACKEND_IMAGE:$IMAGE_TAG -t $BACKEND_IMAGE:latest ./backend
      docker push $BACKEND_IMAGE:$IMAGE_TAG
      docker push $BACKEND_IMAGE:latest
      echo "Backend image built and pushed: $BACKEND_IMAGE:$IMAGE_TAG"
  only:
    - main
    - develop
    - merge_requests

build:frontend:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  <<: *docker_cache
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      echo "Building frontend Docker image..."
      docker build -f frontend/Dockerfile.prod -t $FRONTEND_IMAGE:$IMAGE_TAG -t $FRONTEND_IMAGE:latest ./frontend
      docker push $FRONTEND_IMAGE:$IMAGE_TAG
      docker push $FRONTEND_IMAGE:latest
      echo "Frontend image built and pushed: $FRONTEND_IMAGE:$IMAGE_TAG"
  only:
    - main
    - develop
    - merge_requests

# Test stage - Run unit tests
test:backend:
  stage: test
  image: node:18-alpine
  before_script:
    - cd backend
    - npm ci
  script:
    - |
      echo "Running backend unit tests..."
      npm run test:unit || exit 1
      echo "Backend tests completed successfully"
  artifacts:
    when: always
    reports:
      junit: backend/test-results/test-results.xml
    paths:
      - backend/test-results/test-results.xml
    expire_in: 1 week
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  only:
    - main
    - develop
    - merge_requests

test:frontend:
  stage: test
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Running frontend unit tests..."
      npm run test:unit || exit 1
      echo "Frontend tests completed successfully"
  artifacts:
    when: always
    reports:
      junit: frontend/test-results/test-results.xml
    paths:
      - frontend/test-results/test-results.xml
    expire_in: 1 week
  only:
    - main
    - develop
    - merge_requests

# Deploy to Production Environment (AWS EC2)
deploy:prod:
  stage: deploy-prod
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - touch ~/.ssh/known_hosts       # <-- add this line
    - chmod 700 ~/.ssh
    - chmod 644 ~/.ssh/known_hosts
  script:
    - |
      echo "Deploying to AWS EC2..."

      ssh -o StrictHostKeyChecking=no $PROD_SERVER_USER@$PROD_SERVER_HOST << ENDSSH
        set -e

        echo "Checking disk space..."
        df -h /
        docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
        echo "Pulling latest images..."
        docker pull $BACKEND_IMAGE:latest
        docker pull $FRONTEND_IMAGE:latest

        echo "Stopping old containers..."
        docker stop backend frontend || true
        docker rm backend frontend || true

        echo "Starting backend container..."
        docker run -d --name backend -p 5001:3000 \
        -e NODE_ENV=$NODE_ENV \
        -e PORT=$PORT \
        -e DB_HOST=$DB_HOST \
        -e DB_NAME=$DB_NAME \
        -e DB_USER=$DB_USER \
        -e DB_PASSWORD=$DB_PASSWORD \
        -e DB_PORT=$DB_PORT \
        -e CORS_ORIGIN=$CORS_ORIGIN \
        -e RATE_LIMIT_WINDOW_MS=$RATE_LIMIT_WINDOW_MS \
        -e RATE_LIMIT_MAX_REQUESTS=$RATE_LIMIT_MAX_REQUESTS \
        -e JWT_SECRET=$JWT_SECRET \
        -e FRONTEND_URL=$FRONTEND_URL \
        $BACKEND_IMAGE:latest


        echo "Starting frontend container..."
        docker run -d --name frontend -p 80:3000 $FRONTEND_IMAGE:latest

        echo "Cleaning unused images..."
        docker image prune -af || true

        echo "Deployment finished successfully!"
      ENDSSH
  environment:
    name: production
    url: http://$PROD_SERVER_HOST
  only:
    - main


# Monitoring and notification (optional)
notify:deployment:
  stage: deploy-prod
  image: curlimages/curl:latest
  script:
    - |
      echo "Deployment notification (can be extended with webhooks)"
      # Example: curl -X POST $WEBHOOK_URL -d "Deployment completed"
  only:
    - main
  when: on_success

